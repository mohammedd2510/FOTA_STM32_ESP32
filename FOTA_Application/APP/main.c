/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include"main.h"
#include "MCAL/SCB/SCB_interface.h"

/* Task Handles */
TaskHandle_t InitTaskHandle = NULL;
TaskHandle_t TFTTaskHandle = NULL;
TaskHandle_t DACTaskHandle = NULL;


/* Queue and Semaphore and Timers Handles */
TimerHandle_t RGB_TimerHandler =NULL;
QueueHandle_t TFT_QueueHandler ;
SemaphoreHandle_t AudioSignal_Mutex = NULL;
SemaphoreHandle_t AudioSignalStopFlag_Mutex = NULL;
SemaphoreHandle_t AudioSignalStart_Semaphore = NULL;


/*Global Variables */
u8 RGB_Colors_Counter =0;
const u8 * Copy_pu8Signal = NULL;
u8  Signal_Stop_Flag = ZERO_INIT;
/*********************/

void IR_CALLBACK(void)
{
	u8 TFT_Queue_Send =0;
    if(IR_u32GetReceivedData() == IR_TV_REMOTE_1)
    {
    	TFT_Queue_Send = TFT_AMRDIAB;
    	xQueueSendToFrontFromISR(TFT_QueueHandler,&TFT_Queue_Send,NULL);
    	xTimerStartFromISR( RGB_TimerHandler,NULL );
    }
    else if(IR_u32GetReceivedData() == IR_TV_REMOTE_2)
    {
    	TFT_Queue_Send = TFT_MOUNIR;
    	xQueueSendToFrontFromISR(TFT_QueueHandler,&TFT_Queue_Send,NULL);


    }
    else if(IR_u32GetReceivedData() == IR_TV_REMOTE_EXIT)
    {
    	TFT_Queue_Send = TFT_STOP;
    	xQueueSendToFrontFromISR(TFT_QueueHandler,&TFT_Queue_Send,NULL);

    }
    else if(IR_u32GetReceivedData() == IR_TV_REMOTE_OK)
	{
      SystemReset();
	}
}


void InitTask( void * pvParameters )
	{
		/* Application Modules Init */
		RGB_voidInit(&RGB_Lcfg);
		MNVIC_voidSetPriority(EXTI0_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY+1);
		IR_voidInit(&IR_Config, IR_CALLBACK);
		TFT_voidInit(&TFT_Config);
		R2RDAC_voidInit(&R2RDAC_Config);
		/* Tasks Creation */
		xTaskCreate(TFT_Task,"TFTTask",128,( void * ) NULL, 10,&TFTTaskHandle );
		xTaskCreate(DAC_Task,"DACTask",128,( void * ) NULL, 9,&DACTaskHandle );
		/* Kernel objects Creation */
		RGB_TimerHandler = xTimerCreate( "Timer", 20000, pdTRUE, ( void * ) 0, RGBTimerCallback);
		TFT_QueueHandler= xQueueCreate( 1, sizeof( u8 ) );

		AudioSignal_Mutex = xSemaphoreCreateMutex();
		AudioSignalStopFlag_Mutex = xSemaphoreCreateMutex();
		AudioSignalStart_Semaphore = xSemaphoreCreateBinary();

		xSemaphoreGive(AudioSignal_Mutex);
		xSemaphoreGive(AudioSignalStopFlag_Mutex);


		vTaskDelete(InitTaskHandle);
	}

void TFT_Task( void * pvParameters )
{
	u8 TFT_Queue_Recieve = 0;
	for(;;)
	{
		xQueueReceive( TFT_QueueHandler,  &( TFT_Queue_Recieve ), portMAX_DELAY );
		if(TFT_Queue_Recieve == TFT_STOP){
			TFT_ClearScreen(&TFT_Config); // Clear TFT Screen

	    	xTimerStop( RGB_TimerHandler,portMAX_DELAY ); // Stop RGB Animation
	    	RGB_Colors_Counter =0; // Reset RGB Colors Counter
	    	RGB_voidSetColor(&RGB_Lcfg, RGB_BLACK_COLOR); // Set RGB to Black Color

			xSemaphoreTake(AudioSignal_Mutex,portMAX_DELAY); // Take Audio Signal Mutex
			Copy_pu8Signal = NULL; // set signal pointer to NULL
			xSemaphoreGive(AudioSignal_Mutex); // Give Audio Signal Mutex

			xSemaphoreTake(AudioSignalStopFlag_Mutex,portMAX_DELAY); // Take Audio Signal Stop Flag Mutex
			Signal_Stop_Flag =1; // Set Signal Stop Flag to 1 to stop the current song
			xSemaphoreGive(AudioSignalStopFlag_Mutex); // Give Audio Signal Stop Flag Mutex




		}
		else if (TFT_Queue_Recieve == TFT_AMRDIAB)
		{
			TFT_voidDisplayFullImage(&TFT_Config, AmrDiab_Image); // Display AmrDiab image

			xTimerStart( RGB_TimerHandler,portMAX_DELAY ); // Start RGB Animation

			if(Copy_pu8Signal == NULL){
				xSemaphoreGive(AudioSignalStart_Semaphore); // signaling DAC Task to Start
			}
			xSemaphoreTake(AudioSignal_Mutex,portMAX_DELAY); // Take Audio Signal Mutex
			Copy_pu8Signal = wla_ala_balo_raw; // set signal pointer to wayah_song
			xSemaphoreGive(AudioSignal_Mutex); // Give Audio Signal Mutex

			xSemaphoreTake(AudioSignalStopFlag_Mutex,portMAX_DELAY); // Take Audio Signal Stop Flag Mutex
			Signal_Stop_Flag =1;  // Set Audio Signal Stop Flag to 1 to stop the cuurent song
			xSemaphoreGive(AudioSignalStopFlag_Mutex); // Give Audio Signal Stop Flag Mutex

		}
		else if (TFT_Queue_Recieve == TFT_MOUNIR)
		{
			TFT_voidDisplayFullImage(&TFT_Config, Mounir_Image); // Display Mounir image

		   	xTimerStart( RGB_TimerHandler,portMAX_DELAY ); // Start RGB Animation

			if(Copy_pu8Signal == NULL){
				xSemaphoreGive(AudioSignalStart_Semaphore); // signaling DAC Task to Start
			}
			xSemaphoreTake(AudioSignal_Mutex,portMAX_DELAY); // Take Audio Signal Mutex
			Copy_pu8Signal = she2_men_b3eed_raw; // set signal pointer to ya_lally_song
			xSemaphoreGive(AudioSignal_Mutex); // Give Audio Signal Mutex

			xSemaphoreTake(AudioSignalStopFlag_Mutex,portMAX_DELAY); // Take Audio Signal Stop Flag Mutex
			Signal_Stop_Flag =1; // Set Signal Stop Flag to 1 to stop the current song
			xSemaphoreGive(AudioSignalStopFlag_Mutex); // Give Audio Signal Stop Flag Mutex

		}
	}

}

void DAC_Task( void * pvParameters )
{
	u32 Local_DAC_Counter = ZERO_INIT;
	u8 	Local_DAC_BitCounter = ZERO_INIT;
	u32 Copy_u32SignalLength = AUDIO_LENGTH;

	for(;;)
	{
		Signal_Stop_Flag = 0;
		if(Copy_pu8Signal == NULL){
			xSemaphoreTake(AudioSignalStart_Semaphore,portMAX_DELAY);
		}
		for(Local_DAC_Counter=ZERO_INIT;Local_DAC_Counter<Copy_u32SignalLength;Local_DAC_Counter++)
		{
			for(Local_DAC_BitCounter=ZERO_INIT;Local_DAC_BitCounter<R2RDAC_RESOLUTION;Local_DAC_BitCounter++)
				{
					GPIO_voidSetPinValue
					(
						R2RDAC_Config.R2RDAC_Bit_Port[Local_DAC_BitCounter],
						R2RDAC_Config.R2RDAC_Bit_Pin[Local_DAC_BitCounter],
						GET_BIT(Copy_pu8Signal[Local_DAC_Counter],Local_DAC_BitCounter)
					);
				}
			if(Signal_Stop_Flag == 1){
				break;
			}
			vTaskDelay(20);
		}
	}
}


void RGBTimerCallback(TimerHandle_t xTimer)
{
	u8 RGB_Colors[8]=
	{
			RGB_RED_COLOR ,
			RGB_GREEN_COLOR,
			RGB_BLUE_COLOR  ,
			RGB_YELLOW_COLOR,
			RGB_WHITE_COLOR ,
			RGB_PURPLE_COLOR,
			RGB_CYAN_COLOR  ,
			RGB_BLACK_COLOR
	};
	RGB_voidSetColor(&RGB_Lcfg, RGB_Colors[RGB_Colors_Counter]);
	RGB_Colors_Counter++;
	if(RGB_Colors_Counter == 8){
		RGB_Colors_Counter =0;
	}
}

int main(void)
{
    /* Loop forever */
	xTaskCreate(
			InitTask,       /* Function that implements the task. */
			"InitTask",          /* Text name for the task. */
			128,      /* Stack size in words, not bytes. */
			( void * ) NULL,    /* Parameter passed into the task. */
			TASK_MAX_PRIORITY,/* Priority at which the task is created. */
			&InitTaskHandle );



	vTaskStartScheduler();

	for(;;){

	}
}





